{"remainingRequest":"/Users/sabahathussain/Desktop/HoMakes/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/sabahathussain/Desktop/HoMakes/node_modules/angularfire2/database/query_observable.js","dependencies":[{"path":"/Users/sabahathussain/Desktop/HoMakes/node_modules/angularfire2/database/query_observable.js","mtime":1496439430000},{"path":"/Users/sabahathussain/Desktop/HoMakes/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/sabahathussain/Desktop/HoMakes/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { Observable } from 'rxjs/Observable';\nimport { of as observableOf } from 'rxjs/observable/of';\nimport { combineLatest } from 'rxjs/operator/combineLatest';\nimport { merge } from 'rxjs/operator/merge';\nimport { map } from 'rxjs/operator/map';\nimport { auditTime } from 'rxjs/operator/auditTime';\nimport { OrderByOptions, LimitToOptions } from '../interfaces';\nimport { hasKey, isNil } from '../utils';\nexport function observeQuery(query, audit) {\n    if (audit === void 0) { audit = true; }\n    if (isNil(query)) {\n        return observableOf(null);\n    }\n    return Observable.create(function (observer) {\n        var combined = combineLatest.call(getOrderObservables(query), getStartAtObservable(query), getEndAtObservable(query), getEqualToObservable(query), getLimitToObservables(query));\n        if (audit) {\n            combined = auditTime.call(combined, 0);\n        }\n        combined\n            .subscribe(function (_a) {\n            var orderBy = _a[0], startAt = _a[1], endAt = _a[2], equalTo = _a[3], limitTo = _a[4];\n            var serializedOrder = {};\n            if (!isNil(orderBy) && !isNil(orderBy.value)) {\n                switch (orderBy.key) {\n                    case OrderByOptions.Key:\n                        serializedOrder = { orderByKey: orderBy.value };\n                        break;\n                    case OrderByOptions.Priority:\n                        serializedOrder = { orderByPriority: orderBy.value };\n                        break;\n                    case OrderByOptions.Value:\n                        serializedOrder = { orderByValue: orderBy.value };\n                        break;\n                    case OrderByOptions.Child:\n                        serializedOrder = { orderByChild: orderBy.value };\n                        break;\n                }\n            }\n            if (!isNil(limitTo) && !isNil(limitTo.value)) {\n                switch (limitTo.key) {\n                    case LimitToOptions.First:\n                        serializedOrder.limitToFirst = limitTo.value;\n                        break;\n                    case LimitToOptions.Last: {\n                        serializedOrder.limitToLast = limitTo.value;\n                        break;\n                    }\n                }\n            }\n            if (startAt !== undefined) {\n                serializedOrder.startAt = startAt;\n            }\n            if (endAt !== undefined) {\n                serializedOrder.endAt = endAt;\n            }\n            if (equalTo !== undefined) {\n                serializedOrder.equalTo = equalTo;\n            }\n            observer.next(serializedOrder);\n        });\n    });\n}\nexport function getOrderObservables(query) {\n    var observables = ['orderByChild', 'orderByKey', 'orderByValue', 'orderByPriority']\n        .map(function (key, option) {\n        return ({ key: key, option: option });\n    })\n        .filter(function (_a) {\n        var key = _a.key, option = _a.option;\n        return !isNil(query[key]);\n    })\n        .map(function (_a) {\n        var key = _a.key, option = _a.option;\n        return mapToOrderBySelection(query[key], option);\n    });\n    if (observables.length === 1) {\n        return observables[0];\n    }\n    else if (observables.length > 1) {\n        return merge.apply(observables[0], observables.slice(1));\n    }\n    else {\n        return new Observable(function (subscriber) {\n            subscriber.next(null);\n        });\n    }\n}\nexport function getLimitToObservables(query) {\n    var observables = ['limitToFirst', 'limitToLast']\n        .map(function (key, option) { return ({ key: key, option: option }); })\n        .filter(function (_a) {\n        var key = _a.key, option = _a.option;\n        return !isNil(query[key]);\n    })\n        .map(function (_a) {\n        var key = _a.key, option = _a.option;\n        return mapToLimitToSelection(query[key], option);\n    });\n    if (observables.length === 1) {\n        return observables[0];\n    }\n    else if (observables.length > 1) {\n        var mergedObs = merge.apply(observables[0], observables.slice(1));\n        return mergedObs;\n    }\n    else {\n        return new Observable(function (subscriber) {\n            subscriber.next(null);\n        });\n    }\n}\nexport function getStartAtObservable(query) {\n    if (query.startAt instanceof Observable) {\n        return query.startAt;\n    }\n    else if (hasKey(query, 'startAt')) {\n        return new Observable(function (subscriber) {\n            subscriber.next(query.startAt);\n        });\n    }\n    else {\n        return new Observable(function (subscriber) {\n            subscriber.next(undefined);\n        });\n    }\n}\nexport function getEndAtObservable(query) {\n    if (query.endAt instanceof Observable) {\n        return query.endAt;\n    }\n    else if (hasKey(query, 'endAt')) {\n        return new Observable(function (subscriber) {\n            subscriber.next(query.endAt);\n        });\n    }\n    else {\n        return new Observable(function (subscriber) {\n            subscriber.next(undefined);\n        });\n    }\n}\nexport function getEqualToObservable(query) {\n    if (query.equalTo instanceof Observable) {\n        return query.equalTo;\n    }\n    else if (hasKey(query, 'equalTo')) {\n        return new Observable(function (subscriber) {\n            subscriber.next(query.equalTo);\n        });\n    }\n    else {\n        return new Observable(function (subscriber) {\n            subscriber.next(undefined);\n        });\n    }\n}\nfunction mapToOrderBySelection(value, key) {\n    if (value instanceof Observable) {\n        return map\n            .call(value, function (value) {\n            return ({ value: value, key: key });\n        });\n    }\n    else {\n        return new Observable(function (subscriber) {\n            subscriber.next({ key: key, value: value });\n        });\n    }\n}\nfunction mapToLimitToSelection(value, key) {\n    if (value instanceof Observable) {\n        return map\n            .call(value, function (value) { return ({ value: value, key: key }); });\n    }\n    else {\n        return new Observable(function (subscriber) {\n            subscriber.next({ key: key, value: value });\n        });\n    }\n}\nfunction hasObservableProperties(query) {\n    if (query.orderByKey instanceof Observable)\n        return true;\n    return false;\n}\n//# sourceMappingURL=query_observable.js.map",null]}